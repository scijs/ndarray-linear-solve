{
  "name": "ndarray-ops",
  "version": "1.2.2",
  "description": "Common operations for ndarray arrays",
  "main": "ndarray-ops.js",
  "directories": {
    "example": "example",
    "test": "test"
  },
  "dependencies": {
    "cwise-compiler": "^1.0.0"
  },
  "devDependencies": {
    "tape": "~1.0.4",
    "ndarray": "~1.0.4"
  },
  "scripts": {
    "test": "tap test/*.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/mikolalysenko/ndarray-ops.git"
  },
  "keywords": [
    "ndarray",
    "math",
    "operations",
    "scientific",
    "linear",
    "algebra"
  ],
  "author": {
    "name": "Mikola Lysenko"
  },
  "license": "MIT",
  "readmeFilename": "README.md",
  "gitHead": "dbc9e44102e02575a0de5feb71b47674422d8e49",
  "readme": "ndarray-ops\n===========\nA collection of common mathematical operations for [ndarrays](http://github.com/mikolalysenko/ndarray).  Implemented using [cwise](http://github.com/mikolalysenko/cwise)\n\nUsage\n=====\nFirst, install the library using npm:\n\n    npm install ndarray-ops\n    \nThen you can import the library by doing:\n\n    var ops = require(\"ndarray-ops\")\n\nThen you can use the functions as in the following example:\n\n```javascript\n//First, import libraries\nvar ndarray = require(\"ndarray\")\n  , ops = require(\"ndarray-ops\")\n\n\n//Next, create some arrays\nvar a = ndarray(new Float32Array(128*128))\n  , b = ndarray(new Float32Array(128*128))\n  , c = ndarray(new Float32Array(128*128))\n\n//Initialize b with some random numbers:\nops.random(b)\n\n//Set c to a constant 1\nops.assigns(c, 1.0)\n\n//Add b and c, store result in a:\nops.add(a, b, c)\n\n//Multiply a by 0.5 in place\nops.mulseq(a, 0.5)\n\n//Print some statistics about a:\nconsole.log(\n  \"inf(a) = \", ops.inf(a),\n  \"sup(a) = \", ops.sup(a),\n  \"argmin(a) = \", ops.argmin(a),\n  \"argmax(a) = \", ops.argmax(a),\n  \"norm1(a) = \", ops.norm1(a))\n```\n\nConventions\n===========\nThis library implements component-wise operations for all of the operators and Math.* functions in JS, along with a few commonly used aggregate operations.  Most of the functions in the library work by applying some symmetric binary operator to a pair of arrays. You call them like this:\n\n```javascript\nops.add(dest, arg1, arg2)\n```\n\nWhich translates into code that works (approximately) like this:\n\n```javascript\nfor(var i=0; i<dest.shape[0]; ++i) {\n  dest[i] = arg1[i] + arg2[i]\n}\n```\n\nIt is up to you to specify where the result gets store.  This library does not create new arrays for you to avoid performing expensive intermediate allocations.  There are also a few other variations:\n\n```javascript\nops.addeq(dest, arg1)\n```\nOperators with the -eq suffix perform an assignment.\n\n```javascript\nfor(var i=0; i<dest.shape[0]; ++i) {\n  dest[i] += arg1[i]\n}\n```\n\n```javascript\nops.adds(dest, arg1, 1.0)\n```\nThe -s suffix denotes scalar/broadcast operations; so the above would translate to:\n\n```javascript\nfor(var i=0; i<dest.shape[0]; ++i) {\n  dest[i] = arg1[i] + 1.0\n}\n```\n\n```javascript\nops.addseq(dest, 1.0)\n```\nThe -seq suffix is basically the combination of the above, and translates to:\n\n```javascript\nfor(var i=0; i<dest.shape[0]; ++i) {\n  dest[i] += 1.0\n}\n```\n\nThe following operators follow this rule:\n\n* add[,s,eq,seq] - Addition, `+`\n* sub[,s,eq,seq] - Subtraction, `-`\n* mul[,s,eq,seq] - Multiplication, `*`\n* div[,s,eq,seq] - Division, `/`\n* mod[,s,eq,seq] - Modulo, `%`\n* band[,s,eq,seq] - Bitwise And, `&`\n* bor[,s,eq,seq] - Bitwise Or, `&`\n* bxor[,s,eq,seq] - Bitwise Xor, `^`\n* lshift[,s,eq,seq] - Left shift, `<<`\n* rshift[,s,eq,seq] - Signed right shift, `>>`\n* rrshift[,s,eq,seq] - Unsigned right shift, `>>>`\n* lt[,s,eq,seq] - Less than, `<`\n* gt[,s,eq,seq] - Greater than, `>`\n* leq[,s,eq,seq] - Less than or equal, `<=`\n* geq[,s,eq,seq] - Greater than or equal `>=`\n* eq[,s,eq,seq] - Equals, `===`\n* neq[,s,eq,seq] - Not equals, `!==`\n* and[,s,eq,seq] - Boolean And, `&&`\n* or[,s,eq,seq] - Boolean Or, `||`\n* max[,s,eq,seq] - Maximum, `Math.max`\n* min[,s,eq,seq] - Minimum, `Math.min`\n\n\nSpecial Cases\n-------------\nThere are a few corner cases that follow slightly different rules.  These can be grouped using the following general categories:\n\n### Assignment\n\nThere are two assignment operators:\n\n* assign\n* assigns\n\n`op.assign(dest, src)` copies one array into another, while `op.assigns(dest, val)` broadcasts a scalar to all elements of an array.\n\n### Nullary operators\nNullary operators only take on argument for the array they are assigning to, and don't have any variations.  Currently there is only one of these:\n\n* random - Sets each element of an array to a random scalar between 0 and 1, `Math.random()`\n\n### Unary operators\nUnary operators have one of two forms, they can be written as either:\n\n```javascript\nop.abs(dest, arg)\n```\n\nOr:\n\n```javascript\nop.abseq(dest)\n```\n\nThe former version sets dest = |arg|, while in the latter the operation is applied in place.  ndarray-ops exposes the following unary operators:\n\n* not[,eq] - Boolean not, `!`\n* bnot[,eq] - Bitwise not, `~`\n* neg[,eq] - Negative, `-`\n* recip[,eq] - Reciprocal, `1.0/`\n* abs[,eq] - Absolute value, `Math.abs`\n* acos[,eq] - Inverse cosine, `Math.acos`\n* asin[,eq] - Inverse sine, `Math.asin`\n* atan[,eq] - Inverse tangent, `Math.atan`\n* ceil[,eq] - Ceiling, `Math.ceil`\n* cos[,eq] - Cosine, `Math.cos`\n* exp[,eq] - Exponent, `Math.exp`\n* floor[,eq] - Floor, `Math.floor`\n* log[,eq] - Logarithm, `Math.log`\n* round[,eq] - Round, `Math.round`\n* sin[,eq] - Sine, `Math.sin`\n* sqrt[,eq] - Square root, `Math.sqrt`\n* tan[,eq] - Tangent, `Math.tan`\n\n### Non-symmetric binary operators\nThere are also a few non-symmetric binary operators.  These operators have an extra suffix `op` which flips the order of the arguments.  There are only two of these:\n\n* atan2[,s,eq,seq,op,sop,opeq,sopeq]\n* pow[,s,eq,seq,op,sop,opeq,sopeq]\n\n### Map-reduce (aggregate) operators\nFinally, there are aggregate operators that take an array as input and compute some aggregate result or summary.  These functions don't have any special suffixes and all of them take a single array as input.\n\n* equals - Check if two ndarrays are equal\n* any - Check if any element of the array is truthy\n* all - Checks if any element of the array is falsy\n* sum - Sums all elements of the array\n* prod - Multiplies all elements of the array\n* norm2squared - Computes the squared L2 norm\n* norm2 - Computes the L2 norm\n* norminf - Computes the L-infinity norm\n* norm1 - Computs the L1 norm\n* sup - Max element in array\n* inf - Min element in array\n* argmin - Index of min element\n* argmax - Index of max element\n\nCredits\n=======\n(c) 2013 Mikola Lysenko. MIT License\n",
  "bugs": {
    "url": "https://github.com/mikolalysenko/ndarray-ops/issues"
  },
  "homepage": "https://github.com/mikolalysenko/ndarray-ops",
  "_id": "ndarray-ops@1.2.2",
  "_from": "ndarray-ops@^1.2.1"
}
